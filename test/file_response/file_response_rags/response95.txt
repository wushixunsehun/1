{
    "query": "在 Lustre 文件系统中，read_cache_enable、writethrough_cache_enable和readcache_max_filesize参数分别有什么作用？如何通过这些参数优化 OSS 的缓存策略？",
    "summaries": [
        "OSS 通过读缓存和写通缓存机制优化数据访问。读缓存（read_cache）在处理相同数据的读取请求时，直接使用内存中的数据，提升性能；当禁用时，数据在读取后会被丢弃。写通缓存（writethrough_cache）控制写入数据是否保留在内存中供后续读取，适用于需要立即访问刚写入数据的场景。readcache_max_filesize 参数限制缓存文件的最大大小，适用于小文件重复访问的工作负载。异步日志提交（sync_journal）可提高性能，但可能丢失未提交的数据，需结合恢复功能使用。",
        "本文档介绍了Lustre文件系统中的一些可调参数及其设置方法。主要包括：\n\n1. **writethrough cache enable**：控制是否启用写通缓存，适用于文件写入后不常被读取的情况，建议与缓存共用。\n2. **readcache max filesize**：设置OSs在缓存中保留的文件最大大小，用于优化小文件的缓存使用，避免大文件占用缓存。\n3. **sync journal**：控制是否同步提交文件系统日志，异步提交可提高性能，但可能丢失数据，需根据需求设置。\n4. **sync_lock_cancel**：控制锁取消时是否将日志写到磁盘，用于保证多客户端写入时的数据一致性。\n5. **at_min**：设置自适应超时机制的最短超时时间，用于应对临时网络中断导致的RPC超时。\n6. **adaptive timeout_max**：设置自适应超时机制的最长超时时间，用于估计RPC服务时间上限。\n\n所有参数的设置方法均涉及修改对应节点（如MDT、OST、MGS）的配置文件。",
        "本文档介绍了Lustre文件系统中多个可调参数的设置方法和作用。主要包括：1. RPC匹配表达式的逻辑优先级；2. 设置OST和MGS的nrs_policies为tbf；3. ost_contended_locks参数用于判定数据对象是否处于竞争状态，默认值为32；4. ost_lwp_contended_locks参数用于判定LWP对象是否处于竞争状态；5. 设置fsck速度限制；6. auto_scrub参数控制OI不一致时是否自动运行OI Scrub；7. debug参数设置调试信息的掩码。这些参数用于优化Lustre性能和调试。"
    ],
    "contents": [
        "对相同数据的读取请求时，OSS 将跳过从磁盘读取数据的步又，直接使用绥存中的数据完成请求。读取绥存由 Linux 内核在该 0SS 上的所有 OST上进行全局管理，以便可用内存量不足时从内存中删除最近最少使用的绥存页面。ORAS [read cache (read cache enable=0)，则 OSS 在完成客户端读取请求后丢径数据。处理后续读取请求时，OSS 将再次从磁盘读取数据。在 OSS 的所有 OST 上禁用readq_cache ，请运行:495\nLustre 文件系统操作手册 译者: 李硕root@ossl# lctl set param obdfilter.*.read_ cache enable=0重新在 OST 上局用readq_cache ，请运行:root@ossl# lctl set param obdfilter. {OST name}.read_ cache enable=1# A ltt OSS 的所有 OST 上都司用了read_cache，请运行:root@ossl# lctl get param obdfilter.*.read_ cache enable。 writethrough cache enable 一用于控制发送到 OSS 的写入请求数据是保留在读缓存用于后续读取，还是在写入完成后从绥存中丢弃。默认情况下为司用状AS (writethrough cache enable=1).当 OSS 从客户端接收写请求时，它从客户器接收数据至其内存中并将数据写入磁王。如果司用了writethrough_cache ，则此数据在写入请求完成后将保留在内存中。如果收到相同数据的后续读取请求或部分页面写和请求，OSS 可跳过从磁盘读取此数据的步桑。如果禁用了writethrougnh cache (writethrough cache enabled=0), JlOSS 在完成客户端的写入请求后丢弃数据。处理后续读取请求或部分页面写入请求时，OSS 必须从磁一重新读取数据。当客户端正在执行小数据写入或会导致部分页面更新的未对齐写入，或者其他蔬氮需要立即访问另一个节氮刚写入的文件时，建议司用writethrough_cache。例如，在生产者 -消费者 VO 模型、不同节点的 IO 操作未在 4096 字节边界上对齐的共享文件写入等",
        "默认情况下，如果一个对象互相冲突的LDLM锁大于或等于32个，那么认为该资源处于竞争状态。如果该参数被设置为0 ，则认为所有的资源都处于竞争状态。零值只在调试无锁MO时有用。注意， contention_seconds 的值如果为 0 ，那么资源不会进入竞争状态，无论资源有多少锁冲突。67.2 设置方法将所有OST的 1dlm.namespaces.filter-{{ service name }}_UUID.contended locks 设置为 {{ locks}} >将MGS的 1d1lm.namespaces.filter-.{{ filesystem.fsname }}-OST* UUID.contended_ locks 设置为 {{locks }}.,68. ost_lwp_contended_locks: 设置判定LWP的对象处于竞争状态的锁数量68.1 简介本参数用来设置判定LWP (Light Weight Proxy，轻量级代理) 的对象处于竞争状态的锁数量。双量级代理 (LWP) 管理从OST到MDT，以及MDT到MDT0建立的连接。LWP连接用来发送配额和FLD查询请求。该连接是不可恢复的，这意味着目标服务器不会在last_rcvd文件中将关于该连接记录记录在磁盘上。所以，如果服务器发生了重启，LWP重新连接，服务器将始终把这个连接视为一个全新的连接。注意， contention_seconds 的值如果为 0 ，那么资源不会进入竞争状态，无论资源有多少锁冲突。关于竞争状态、无锁MO的介绍，请参看参数ost_ contended locks。68.2 设置方法将所有0OST的 1ldlm.namespaces.{{ fsname }}-MDT*-lwp-OST*.contended_ locks 设置为 {{ locks }};3将MGS的 1d1m. namespaces. {filesystem. fsname}-MDT*-lwp-OST*.contended_locks 设置为{{ locks}} 。作者: 李希 更新时间: 2023年6月7日\nLustre 可调参数全解将所有0OST的 mdd.{{ service name }}.1fsck speed limit 设置为{{ objects }};将MGS的 obdfilter.{{ filesystem.fsname",
        "Lustre 可调参数全解将所有0OST的 mdd.{{ service name }}.1fsck speed limit 设置为{{ objects }};将MGS的 obdfilter.{{ filesystem.fsname }}-OST*.1fsck speed limit 和maqqd.{{filesystem.fsname }}-MDT*.1fsck_ speed limit 设置为 {{ objects }}.77. auto_scrub: 设置检测到OI不一致时是否运行O1 Scrub77.1 简介本参数用来设置检测到对象索引表 (Object Index, Ol) 不一致时是否运行清理 (Ol Scrub) 。本参数控制在OI查找过程中检测到不一致时是否会触发Ol Scrub,如果该参数值为 1 ，表示如果在OI查找过程中检测到不一致，Lustre将自动启动OI Scrub。如果值为 0 ，Lustre将不会自动启动OI Scrub,在挂载Lustre服务时，可以指定一个 noscrub 挂载选项。如果指定了 noscrub 挂载选项，auto_scrub功能也将茜用，也就是即使检测到了OlI不一致，也不会触发OI Scrub 。在挂载完成后，可以使用本参数中所示的命令重新启用auto_scrub功能。在挂载后才手动启动LFSCK，可以对启动条件进行更精准的控制。77.2 设置方法将所有MDT和OST的 osd-ldiskfs.{{ service name }}.auto_scrub 设置为 {{ auto }}将MGS的 osd-ldiskfs.{{ filesystem.fsname }}-*.auto_scrub 设置为{{ auto })} 。78. debug: 设置调试信息的掩码78.1 简介KE 数用来设置调试信息的掩码。Lustre内部的调试信息会写入一个不断循环的调试缓冲区 (不同于错误信息，错误信息会打印到syslog或控制台) 。日志大小默认每CPU只有5MB，但可以增加，因为一个繁忙的系统会很快写满这5MB。当缓冲区填满时，最早的日志记录会被丢弃。本参数控制了Lustre调试日志中的会出现哪些条目。下列掩码可以在该参数中使用:trace, inode, super, tty, malloc,",
        "}}.作者: 李希 更新时间: 2023年6月7日\nLustre 可调参数全解93. sync journal: 设置是否同步提交文件系统日志93.1 简介本参数用来设置是否同步提交文件系统日志 (Journal) 。OSs的异步日志提交功能会异步地将数据写入磁盘，而不会强制进行日志刷新。这减少了寻道次数，可以在某些硬件环境下明显地提高性能。异步日志提交无法用于Direct MO的写入 (设置了o_DIREcT 标志) 。对这种MO请求，将强制执行日志刷新。启用异步日志提交功能后，客户端节点会将数据保留在页面缓存中 (增加页面引用) 。 Lustre客户端将监视从O5SS发送到客户端的消息中的最后提交的交易号 (TransactionNumber, transno) 。当客户端看到OSs报告的最后一个 是交的 transno = BIDS 等于批量写入的 transno AY, 它会在相应的页面上释放5引用。 为了避免批量写入后，持有页面引用对时间过长，客户端在收到批量写入的回复后将发起7秒的ping请求 (0SS文件系统提交默认时间间隔为5秒) ，以便OSSs报告最后提交的transno 。如果O55在日志提交发生之前谢演， 则中间数据就会丢失。然而，包含了异步日志提交功能的0Ss恢复功能会要求客户端重发与请求，然后通过恢复文件系统的状态来恢复丢失的磁盘更新。默认情况下， sync journal 被禁用 (sync journal=0) ，因此，文件系统日志条目不会同步提交。如需禁用异步日志提交，请将 sync_jouzrnal 参数设为1。93.2 设置方法将所有OST的 obdfilter.{{ service name }}.sync journal 设置为 {{ sync }};将MGS的 obdfilter.{{ filesystem.fsname }}-OST*.sync journal 设置为 {{ sync }}.94. sync_lock_cancel: 设置是否在锁取消时将日志写到磁盘94.1 简介本参数用来设置是否在锁取消时将日志写到磁盘sync-on-lock-cancel解决下面场景下的数据一致性问题: 在多个客户端向一个对象的交叉区域写入",
        "时将日志写到磁盘94.1 简介本参数用来设置是否在锁取消时将日志写到磁盘sync-on-lock-cancel解决下面场景下的数据一致性问题: 在多个客户端向一个对象的交叉区域写入数据后，如果这个OSS骨溃，而且不巧其中一个客户端也骨溃了，这种情况就有可能会违反POSIX对连续写入的语义要求，而且数据可能遭受损坏。在启用了sync-on-lock-cancel功能后，如果被取消的锁上附加了任何易失性的写入，OSS会在撤销锁时同步将文件系统日志写到磁盘。茜用锁取消同步日志功能可以提高并发写的性能，但不推荐禁用这一功能。sync_1lock_cancel 参数可以设置为以下值:e always: 始终在锁取消时强制进行日志刷新。e blocking: 仅由于阻塞回调触发锁取消时，才强制进行日志刷新。e never: 不强制执行任何日志刷新。94.2 设置方法将所有OST的 obdfilter.{{ service name }} .sync lock cancel 设置为 {{ condition }};将所有MDT的 mdt.{{ service name }}.sync_ lock cancel 设置为 {{ condition }};将MGS的 obdfilter.{{ filesystem.fsname }}-OSTx .sync_ lock cancel 与作者: 李希 更新时间: 2023年6月7日\nLustre 可调参数全解本参数控制自适应超时机制的最短超时时间，单位为秒，默认值为 0 。客户端以该值为基础进行超时处理，但并不直接使用该值。如果由于某些的原因 〈通单是由于临时的网络中断) ，自适应超时值太短，而导致客户端的RPC超时，则可以通过增加 at_min 的值来补偿。97.2 设置方法将Lustre客户端或服务器的 at_min 设置为 {{ seconds }};将MGS的 at_min 设置为 {{ seconds }} 。98. adaptive timeout_max: 设置自适应超时机制的最长超时时间98.1 简介本参数用来设置自适应超时机制的最长超时时间。本参数是对RPC服务时间的上限估计",
        "需要立即访问另一个节氮刚写入的文件时，建议司用writethrough_cache。例如，在生产者 -消费者 VO 模型、不同节点的 IO 操作未在 4096 字节边界上对齐的共享文件写入等例子中，司用writethrough_cache可能会非常有用。相反，当大部分 IO 为文件写入且在短时间内不会被重新读取，或者文件仅由同一节点写入和重新读取时，无论 VO 是否对齐，建议禁用writethrough_cache。要在 OSS 的所有 OST 上禁用writethrough_ cache，请运行:root@ossl# lctl set param obdfilter.*.writethrough cache enable=0重新在 OST 上局用writethrough_ cache，请运行:root@ossl# lctl set param obdfilter.{OST name}.writethrough cache enable=1查看此 OSS 的所有 OST La Fa fwritethrough cache，请运行:root@ossl# lctl get param obdfilter.*.writethrough cache enable* readcache max filesize一用于控制eadq_cache和writethrough cache试保留在内存中的文件的最大大小。大于r*eadcache max filesize的文件，无论进行读取或写入，都不会保存在缓存中。设置此可调参数对于多个客户端重复访问相对较小的文件的工作负载〈如作业局动文件，可执行文件，日志文件等) 非常有用。由于大型文件只能读取或写入一次，如果不将较大的文件放入缓存中，则更多较小的文件能在缓存中保留更长的时间。490\nLustre 文件系统操作手册 译者:设置readcache _ max filesize时，输入值可以以字刷为单位指定，也可以使用后缀来指示其他二进制单位〈如玉《〈干字节)、M OB). G (PIES). T (大字TH). P (FIBF TH) )。在 OSS 的所有 OST 上将最大绥存文件大小限制为 32 MB ，请运行:root@ossl# lctl set param obdfilter.*.readcache max filesize=32MteaX{£ OST 上禁用readcache max filesize，请运行:root@ossl# lctl set param obdfilter",
        "dd.0},nid={192.168.1.[1-128]@tcp 0@1lo}主意，在表达式中, “逻辑与\"的优先级高于“逻辑或\"。所以，上述表达式匹配两类RPC，一类RPC的 opcodeost write (即为读写操作) ，并且 jobid 为 dda.0 ; 另外一类RPC须来自于NID处于区间 192.168.1.1@tcp到192.168.1.128etcp 的节点或者来自本OST (0elo) 。59.2 设置方法将所有OST的 ost.OSS.{{ service }}.nrs_ policies 设置为tbf ;将MGS的 ost.OSS.{{ service }}.nrs_ policies 设置为tbf ;作者: 李希 更新时间: 2023年6月7日\nLustre 可调参数全解将所有MDT的 ~mds.MDS.{{ service }}.nrs tbf rule 设置为stop {{ name }};将MGS的 ~mds.MDS.{{ service }}.nrs_ tbf rule 设置为 stop {{ name }} 。67. ost contended locks: 设置判定数据对象处于竞争状态的锁数量67.1 简介本参数用来设置判定数据对象处于竞争状态的锁数量。在客户端开始执行MO之前，需要从服务器获得LDLM锁。服务器端对每个共享资源 《如数据对象或元数据对象)都维护了其LDLM锁的已授予 (Granted) 和正在等待授予锁的队列。如果这个两个队列中互相冲突的锁数目超出了一定阔值，那么可以认为该资源处在竞争状态 (Contended) 。对于一个处在竞争状态下的对象，服务器将拒绝再增加任何LDLM锁。当客户端收到此拒绝回复，就知道资源处于竞争状态了，客己端融会对疡执行无锁IMO。在无锁I/O状态下，客户端不再获取LDLM锁，服务器服务器代蔡客户端执行加锁操作，这样可以快速地完成MO，而避免锁的乒乓效应。默认情况下，如果一个对象互相冲突的LDLM锁大于或等于32个，那么认为该资源处于竞争状态。如果该参数被设置为0 ，则认为所有的资源都处于竞争状态。零值只在调试无锁MO",
        "。相反，当大部分MO为文件写入且在短时间内不会被重新读取，或者文件仅由同一节点写入和重新读取时，无论/O是否对齐，都建议共用与缓存。91.2 设置方法将所有MDT和OST的 osd-ldiskfs.{{ service name }}.writethrough cache enable 设置为 {{ enable}}，将MGS的 osd-ldiskfs.{{ filesystem.fsname }}-*.writethrough cache_enable 设置为{{ enable}} 。92. readcache max filesize: 设置0SSs在缓存中保留的文件的最大大小92.1 简介本参数用来设置0SS在缓存中保留的文件的最大大小。该参数控制读缓存和写缓存试图保留在内存中的文件的最大大小。大于 readcache max filesize 的对象，无论进行读取或与入，无论是否设置了 writethrough cache enable read cache enable, #RARFEBEE中。设置该参数对于下面这种工作负载非常有用: 相对较小的文件 〈比如工作局动文件、可执行文件、日志文件等) 被许多客户端重复访问，而大文件通常只被读或写一次。不把大文件放入缓存，就意味着更多较小的对象有更大概率能在缓存中保留更长的时间。当设置 readcache max filesize AY, 输入值可以用字节为单位， 也可以使用后缀来表示其他二进制单位， 如K(FED) 、M KF) 、G (〈王兆字节) 、T (AFD) RP (FAICED) 。如需茶用此限制，请将此参数设置为 -1 。92.2 设置方法将所有MDT和OST的 osd-ldiskfs.{{ service name }}.readcache max filesize 设置为{{ max }};3将MGS的 osd-ldiskfs.{{ filesystem.fsname }}-*.readcache max filesize 设置为{{ max }}.作者: 李希 更新时间: 2023年6月7日\nLustre 可调参数全解93. sync journal: 设置是否同步提交文件系统日志93.1 简介本参数用来设置是否同步提交文件系统日志",
        "root@ossl# lctl set param obdfilter.*.readcache max filesize=32MteaX{£ OST 上禁用readcache max filesize，请运行:root@ossl# lctl set param obdfilter. {OST name}.readcache max filesize=-1l查看是否 OSS 的所有0OST Laila FA freadcache max filesize，请运行:root@ossl# lctl get param obdfilter.*.readcache max filesize39.4.4. 启用 OSS 异步日志提交OSS 异步日志提交功能将数据异步地写入磁盘，而不强制进行日志刷新。这将减少搜索次数，并显著提高了某些硬件的性能。注意异步日志提交不能用于直接的 IO 发起的写入〈设置了oO_DIRECT标志)。在这种情况下，将强制执行日志刷新。局用异步日志提交功能后，客户端节点会将数据保留在页面绥存中《页面引用)。Lustre 客户端将监视从 OSS 发送到客户端的消息中的最后提交的交易号 (transno)。当客户端看到 OSS 报告的最后一个提交的tr*ansno至少等于批量写入的trzansno时，它会在相应的页面上释放引用。为避免批量写入后客户端上的页面引用时间过长，在收到批量写入的回复后将发起 7 秒的 ping XK (OSS 文件系统提交默认时间间隔为 3 BD),以便 OSS 报告最后提交的transno。如果 OSS 在日志提交之前崩溃，则中间数据将丢失。但是，结合异步日志提交的OSS 恢复功能能够使客户端重放其写入请求，并通过恢复文件系统的状态来补偿丢失的磁盘更新。默认情况下，sync_journal为启用状态 (sync_journal=1)，以便同步提交日记条目。局用异步日志提交，请输入以下内容将sync_journal参数设置为 0:—$ lctl set_param obdfilter.*.sync_journal=02 obdfilter.lol-OST0001.sync_journal=0AKA sync-on-lock-cancel 功能〈黑认司用) WRIT 2 he Pi Be BS入对象的交叉区域后的 OSS 及其中一个客户端朋省时可能导致的数据不一致问题。当违反连续写入的"
    ]
}