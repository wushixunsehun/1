{
    "query": "statahead机制通常会预取文件的元数据。文件的元数据存储在Lustre的MDT上，但文件的大小和其消耗的空间则由OST决定。如何开启 statahead_agl参数，开启后会影响什么？",
    "summaries": [
        "Lustre 文件系统中，脚本通毅使用通配符统一管理客户端参数。文件 readahead 和目录 statahead 用于预读数据和元数据，提升访问效率。readahead 在顺序读取时触发，控制最大预读量的参数包括 `max_read_ahead_mb` 和 `max_read_ahead_per_file_mb`。目录 statahead 提高目录遍历性能，相关参数有 `statahead_max` 和 `statahead_agl`。OSS 读缓存通过 Linux 页面缓存提高性能，适用于多客户端读取场景，可通过 `read_cache_enable` 控制是否启用。",
        "文本主要介绍了Lustre文件系统中添加和管理MDT（元数据目标）及OST（对象存储目标）的操作步骤。包括在下一个可用索引处添加新的MDT设备、挂载MDT、创建文件或目录并指定其所在的MDT，以及添加新OST、平衡OST空间使用和移除或恢复MDT/OST的方法。同时提到将OST或MDT设置为不活跃状态的场景和影响，以及如何永久停用MDT。",
        "使用MobaXterm通过yhalloc申请计算节点，加载virtualgl环境并连接至节点。在节点中加载singularity模块，进入容器后启动Abaqus 2022，通过环境变量调用cae界面进行可视化操作。"
    ],
    "contents": [
        "【已解决】singularity打开abaqus可视化\n**标签**: abaqus\n**创建时间**: 2024-08-19 17:43:33\n**更新时间**: 2024-08-19 17:43:33\n**作者**: 梁言\n在eX上节点可视化使用的步骤如下：\n用的是mobaxterm，步骤如下：\n# 使用yhalloc申请一个计算节点\nyhalloc -N 1 -p cp6\n#  加载virtualgl 环境\nmodule add virtualgl\n# 使用vglconnect到刚才申请的节点\nvglconnect  cn***\n# 计算节点上面操作\nsource  /fs2/software/modules/bashrc\nmodule add singularity/3.11.0\nexport SINGULARITY_TMPDIR=/dev/shm\n# 进入容器\nsingularity shell /fs2/software/node/redhat8.5.sif\n# 在容器中启动软件\n# 启动abaqus2022\nsource ~/env_abq2022\n##env_abq2022内容\n/fs2/home/liangyan/abaqus/2022-program/abq cae -mesa",
        "要禁用 readahead, tf设置max_ read ahead mb=0。* llite.fsname instance.max read ahead per file mb一当获取到文件上的读取顺序时，用于控制客户端应该预读取的最大数据兆字布数 (MiB).是每文件的预读取限制，不能大于max_readq ahead mb。* llite.fsname-instance.max read ahead whole mb 一用于控制完整读取文件的最大大小〈无论read () 的大小) 。这避免了在读取整个文件之前无法有效获取顺序读取模式时对相对较小的文件的多个 RPC 读取。默认值为2 MiB 或一个RPC 的大小 如max_pPages_pet_rpc 中给定的值)。39.4.2.2. 目录 Statahead FJ AGL 的调试”许多系统命令 (Mls -LI、dqu和findq) 按顺序遍历目录。为使这些命令高效运行，可以启用目录 statahead 来提高目录遍历性能。statahead 相关可调参数有:* statahead max 一用于控制由 statahead 线程预取的最大文件属性数量。statahead默认局用，statahead max默认为 32 个文件。禁用 statahead，请在客户端上设置 =statahead max0 :lctl set Param llite.*.statahead_max=0在客户端上更改最大 statahead 窗口大小:lctl Set Param llite.*.statahead_max=n最大statahead max 为8192 个文件。目录 statahead 线程同时也会从 OST 预取文件大小或块属性，以便应用程序需要时获取客户端上的所有文件属性。这是由异步 glimpse 锁 (AGL) 设置控制，可通过以下命令禁用 AGL 行为lctl set Param llite.*.statahead_agl=0* statahead stats 一只读接口，可提供当前 statahead 和 AGL 统计信息，如目上次挂载以来已触发 statahead/AGL 的次数、由于预测错误或其他原因导致的statahead/AGL 故障次数等。注意AGL 处理的inode 是由 statahead 线程构建的，AGEL 行为因此受 statahead 的影响。如果禁用了 statahead，则 AGL",
        "lctl dl 碍看所有 OST 的列表。以下示例为添加一个新的OST 至 testis 文件系统，索引为 12:oss# mkfs.lustre --fsname=testfs --mgsnode=mdsl6@tcp0 --ost--index=12 /dev/sda oss# mkdir -p /mnt/testfs/ost1l2 oss# mount-t lustre /dev/sda /mnt/testfs/ost122. 平衡 OST 空间使用。当新的空白 OST 庆加到相对拥挤的文件系统时，可能导致该文件系统的不平衡。但由于正在创建的新文件将优移放置在新的空白 OST EAB ATA OST 上，以目动平衡文件系统的使用量，如采这是一个暂存的或定期进行文件修胡的文件系统，则可能不需要进一步的操作来平衡 OST 空间使用率。当旧文件被删除时，原 OST 上的相应空间被释放。可使用Lfs_migrate 有选择性地重新平衡扩展前就存在的卓文件，从而使得所有OST 上的文件数据被重新分配。例如，重新平衡 /mnt/lLustre/dir目录下的所有文件，请输入:ClLient# lfs migrate /mnt/lustre/dir将0ST0004 上 /test文件系统中所有大于 AGB 的文件迁移至其他 OSTs，请输入:Client上# lfs find /test --ost test-OST0004 -size +4G |lfs migrate -y143\nLustre 文件系统操作手册 译者: Pa14.9. 移除及恢复 MDT和OST可从 Lustre 文件系统中将 OST 和 DNE MDT 移除并恢复。将 OST 设置为不活跃状态意味着它将暂时或永久地被标记为不可用。将 MDS 上将 OST 设置为不活跃状态，意A CA RSS TE MDS 上分配新对象或执行 OST 恢复; 而在客户端上将 OST 设置为非活动状态则意味着: 在无法联系上 OST 的情况下，它不会等待 OST 恢复，而是fe OST 文件被访问时立即将 IO 错误返回给应用。在特定的情况下或运行特定的命令，OST 可能会永久地在文件系统中停用。",
        "，它不会等待 OST 恢复，而是fe OST 文件被访问时立即将 IO 错误返回给应用。在特定的情况下或运行特定的命令，OST 可能会永久地在文件系统中停用。注意永久停用的MDT 或 OST 仍会出现在文件系统配置中，直到使用 writeconf 重新生成配置或新 MDT 或 OST 在同一索引位置蔡代原设备并永久激活。1fs df不会列出已俘用的 OST.在以下情况中，您可能希望在 MDS 上和暂时地停用 OST 以防止新文件写入:。 硬盘驱动器出现故障并正在进行RAID 重新则步或重建。(OST 在此时也可能被RAID ABIL degraded ，以避免在慢速 OST 上分配新文件，从而降低性能。。OST 接近其空间容量。(尽管 MDS 在这种情况下会尽可能和尝试避免在过度拥挤的OST 上分配新文件。)。MDTOST 存储或 MDS/OSS 布点故障并持续 〈或永久) 不可用，但文件系统在修复前仍须继续工作。(Lustre 2.4 中引入)14.9.1. 在文件系统中移除 MDT如果 MDT 永久不可用, 可使用1fs rm_entry {directory} 删除该MDT WE录条目，由于 MDT 处于不活跃状态，使用 xmqit 将导致 IO 错误。请注意，如果 MDT可用，则应使用标准的 rm -z 命令来删除远程目录。该删除操作完成后，管理员应使用以下命令将 MDT 标记为永久停用状态:letl conf param {MDT name}.mdc.active=0用户可使用 1fs 工具确认含有远程子目录的 MDT, un:1 client$ lfs getstripe --mdt-index /mnt/lustre/remote_ qirl213 client$ mkdir /mnt/lustre/local_dir04 client$ lfs getstripe --mdt-index /mnt/lustre/local_ dir0d50lfs getstripe --mdt-indqex命令返回服务于当前给定目录的MDT 3<4]144\nLustre 文件系统操作手册 译者: Pa14.9.2. 不活跃的MDT位于不活跃 MDT 上的文件",
        "或其他原因导致的statahead/AGL 故障次数等。注意AGL 处理的inode 是由 statahead 线程构建的，AGEL 行为因此受 statahead 的影响。如果禁用了 statahead，则 AGL 也会被禁494\nLustre 文件系统操作手册 译者:这ay39.4.3. OSS 读缓存的调试OSS 读绥存功能在 OSS 上提供数据的只读缓存，通过 Linux 页面缓存来存储数据。它会使用分配的所有物理内存。OSS 读绥存可在以下情况提高 Lustre 文件系统性能:。许多客户端访问相同的数据集 (如在 HPC 应用程序中或无盘客户端从 Lustre 文件系统引导时)。”一个客户站正在存储数据，而另一个客户端正在读取数据《〈即客户端通过 OST 交换数据)。© 客户端目身的缓存非常有限。OSS 读缓存提供了以下好处:\"允许 OST 更频标地绥存读取数据。。 改进重复读取以匹配网络速度而不是磁盘速度。\"提供构建 OST 写缓存〈小数据写入聚合) 的块。39.4.3.1. OSS 读缓存的使用 0SS 读缓存是在 OSS 上实现的，不需要客户端的任何特殊支持。由于 OSS 读缓存使用 Linux 页面缓存中可用的内存，因此应根据 IO 模式来确定适当的缓存内存量。如果主要是读取数据，则需要比主要为写入的 IO 模式需要更多LAE.可使用以下可调参数管理 OSS 读绥存:。 read_cache enable 一用于控制在读取请求期间从磁盘读取的数据是售保留在内存，以便于应付随后对相同数据的读取请求而无需从磁盘重新读取。默认情况下为局用状态 (read_cache_ enable=1).当 OSS 从客户端收到读取请求时，它会将数据从磁盘读取到其内存中，并将数据作为对该请求的回复。如果局用了read_cache，则在满足客户端请求后，此数据将保留在内存中。当接收到后续对相同数据的读取请求时，OSS 将跳过从磁盘读取数据的步又，直接使用绥存中的数据完成请求。读取绥存由 Linux 内核在该 0SS 上的所有 OST上进行全局管理",
        "144f-9359-b063-8477566eb84e 537 UP mdc test£s-MDTO0001-mdc-fff£88004edE£3c004c8be054-144f-9359-b063-8477566eb84e 538 UP mdc testf£s-MDTO002-mdc-fff££88004edE£3c004c8be054-144f-9359-b063-8477566eb84e 539 UP mdc test£s-MDTO003-mdc-fff£88004edE3c004c8be054-144f-9359-b063-8477566eb84e 52. 在下一个可用的索引处添加新的块设备作为 MDT。在下面的例子中，下一个可用索引为 4。mds# mkfs.lustre --reformat --fsname=testfs --mdt--mgsnode=mgsnode --index 4 /dev/mdt4 device142\nLustre 文件系统操作手册 译者:这ay3. 挂载 MDT.mds# mount -t lustre /dev/mdt4 blockdevice /mnt/mdt44. 在新的 MDT 上创建新的文件或目录，须通过 1fs mkdir 命令将它们附加在命名空间的一个或多个子目录上。除非妃外指定，否则通过 lis mkdiz创建的所有从属的文件和目录也将在同一个 MDT 上被创建。client# lfs mkdir -i 3 /mnt/testfs/new dir on mdt3client# lfs mkdir -i 4 /mnt/testfs/new dir on mdt4client# lfs mkdir -c 4 /mnt/testfs/new directory striped across 4 mdts14.8. 在 Lustre 文件系统中添加新的OST可在 Lustre 文件系统中将新的 OST 添加人至现有的 OSS A A BIGATHY OSS LE. Wy维持客户端在多个 OSS 布点上的 IO 负载均衡，实现最大的总体性能，建议不要为每个OSS 下点配置不同数量的 OST.1. 当文件系统第一次进行格式化时，使用mkfs .1ustte 命令湛加新的 OST。每个新的 OST 必须有一个唯一的索引，可使用 lctl dl 碍看所有 OST 的列表。以下示例为添加一个新的OST 至 testis 文件系统，索引为 12:oss# mkfs.lustre --fsname=testfs --mgsnode=mdsl6",
        "脚本通毅会使用通配符“或文件系统专用的通配符 fname-* 来统一指定所有客户端上的参数设置。比如说1 lctl get_param osc.testfs-OST0000-osc-fffF88107412f400.rpc_ stats2 osc.testfs-OST0000-osc-ffff88107412F400.rpc_stats=3 snapshot time: 1375743284 .337839 (secs.usecs)4 read RPCs in flight: 05 write RPCs in flight: 039.4.2. 文件 Readahead 和目录 Statahead 的调试文件 readahead 和目录 statahead 人允许在进程请求数据之前将数据读入内存。文件readahead 将文件内容预取到内存中以进行与ead () 相关调用，而目录 statahead 将文件元数据提取到内存中以进行readqir ()和stat ()相关调用。当 readahead 和 statahead运行良好时，访问数据的进程可在请求时立即在客户端的内存中获取所需的信息，而没有网络 IO HEIR.39.4.2.1. 文件 Readahead = *4 Linux 绥神区高速缓存中的数据无法满足应用程序的两个或更多顺序读取时，将触发文件 readahead。初始预读的大小由 RPC 大小和文件条市大小决定，通首至少为1 MB ，附加的预读将线性增长并递增，直到客户端上的预读绥存到达了每个文件或每个系统的预置量绥存限制。Readahead 相关可调参数有:* llite.fsname-instance.max read ahead mb 一用于控制文件预读的最大数据量。在文件描述符上第二次顺序读取之后，预读文件至 RPC 大小的块(4MiB 或更大的read () 大小) 中。随机读取的大小只能为reaq () 调用大小《无TSE) 。读取文件至非连续区域会重置预读算法，并且在再次顺序读取之前不会再次触发预读。493\nLustre 文件系统操作于册 译者:DCZR At这是对所有文件的全局限制，不能大于客户端RAM 的12。要禁用 readahead, tf设置max_ read ahead mb=0。* llite.fsname instance.max read ahead per file mb一当获取到文件上的读取顺序时，用于控制"
    ]
}